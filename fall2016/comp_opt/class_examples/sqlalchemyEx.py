import sqlalchemy

# This is how we connect to the data base engine below
# In this example, we are creating the data base using SQLite, in memory
# But, we could do this in other ways: using postgres, mysql, oracle, or sqlite on disk
#
engine = sqlalchemy.create_engine('sqlite://')


# There are a thousand ways to interact with the data tables
# One way I like, is to forget about SQL as much as possible, and use python
# to define our tables etc.
#
import sqlalchemy.ext.declarative
import sqlalchemy.orm

Base = sqlalchemy.ext.declarative.declarative_base()

# Lets create a 'student' table
# Here, we define all the attributes that a student has
#
class Student(Base):
    __tablename__ = 'students'

    id = sqlalchemy.Column( sqlalchemy.Integer, primary_key=True)
    lastname = sqlalchemy.Column( sqlalchemy.String)
    firstname = sqlalchemy.Column( sqlalchemy.String)
    major_id = sqlalchemy.Column( sqlalchemy.Integer, sqlalchemy.ForeignKey('majors.id'))
    score = sqlalchemy.Column( sqlalchemy.Float)

    def __repr__(self):
        return "<Student(id='%d', firstname='%s', lastname='%s', score='%s', major='%s')>" % (self.id, self.firstname, self.lastname, self.score, self.major_id)



class Major(Base):
    __tablename__ = 'majors'

    id = sqlalchemy.Column( sqlalchemy.Integer, primary_key=True)
    name = sqlalchemy.Column( sqlalchemy.String)

    students = sqlalchemy.orm.relationship("Student", order_by="Student.id", backref="major")

    def __repr__(self):
        return "<Major(name='%s', id='%d')>" % (self.name, self.id)


# Base contains information for all the tables we want to deal with
# In an attribute called Base.metadata
#
# We can now create all the tables

Base.metadata.create_all(engine)

# Or, you can create them one at a time

Major.__table__.drop(engine)
Major.__table__.create(engine)

# Now lets put some data in there and do some queries
#
# First, we have to connect to the data base through 
# A session

session_maker = sqlalchemy.orm.sessionmaker()
# connect to our database
session_maker.configure(bind = engine)

# now pull out a single connection... a program might have multiple

session = session_maker()

# Lets add some data
# Of course, SQLAlchemy gives you 1000 ways to do this...
# This is just one

session.add( Major(id=1, name='Operations Research') )
session.add( Major(id=2, name='Mechanical Engineering') )

session.add( Student(id=1, firstname='Ned', lastname='Dimitrov', major_id=1, score=20) )
session.add( Student(id=2, firstname='John', lastname='Smith', major_id=2, score=100) )
session.add( Student(id=3, firstname='Jane', lastname='Williams', major_id=1, score=100) )

# Write out everything to the data base

session.commit()

# Query all the students

session.query(Student).all()

# Query all the OR Majors

session.query( Student.id, Student.firstname, Student.lastname, Major.name ).filter( Student.major_id == Major.id).filter(Major.name == 'Operations Research').all()

# Query all the OR Majors using the foreign key relationships we set up

orMajor = session.query( Major ).filter(Major.name == 'Operations Research').first()

orMajor.students

n = orMajor.students[0]

n.major

# Take a look at the complex SQL statements generated by our queries

def debug_inline_params(aquery, bind=None):
    """Compiles a query or a statement and inlines bindparams.

    WARNING: Does not do any escaping."""
    return aquery.statement.compile(compile_kwargs={"literal_binds": True}).string


aquery = session.query( Student.id, Student.firstname, Student.lastname, Major.name ).filter( Student.major_id == Major.id).filter(Major.name == 'Operations Research')

print str(aquery)

print debug_inline_params(aquery)
